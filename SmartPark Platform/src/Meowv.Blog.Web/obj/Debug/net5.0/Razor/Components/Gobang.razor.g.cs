#pragma checksum "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "751499508cd781a1577170a8f8ddbd88aad94ea4"
// <auto-generated/>
#pragma warning disable 1591
namespace Meowv.Blog.Web.Components
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#nullable restore
#line 1 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
using Microsoft.AspNetCore.Components.Web;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
using Meowv.Blog.Web.Models.Gobang;

#line default
#line hidden
#nullable disable
    public partial class Gobang : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
            __builder.OpenElement(0, "div");
            __builder.AddAttribute(1, "class", "post-wrap");
            __builder.OpenElement(2, "div");
            __builder.AddAttribute(3, "class", "gobang-box");
            __builder.OpenElement(4, "div");
            __builder.AddAttribute(5, "class", "chess");
#nullable restore
#line 9 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
             for (var i = 0; i < 19; i++)
            {
                

#line default
#line hidden
#nullable disable
#nullable restore
#line 11 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                 for (var j = 0; j < 19; j++)
                {
                    var _i = i;
                    var _j = j;

#line default
#line hidden
#nullable disable
            __builder.OpenElement(6, "div");
            __builder.AddAttribute(7, "class", "cell");
            __builder.AddAttribute(8, "onclick", Microsoft.AspNetCore.Components.EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, 
#nullable restore
#line 15 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                                  async () => await Playing(_i, _j)

#line default
#line hidden
#nullable disable
            ));
            __builder.OpenElement(9, "span");
            __builder.AddAttribute(10, "class", "chess" + (
#nullable restore
#line 16 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                            Chess[i, j]

#line default
#line hidden
#nullable disable
            ));
            __builder.CloseElement();
            __builder.CloseElement();
#nullable restore
#line 18 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                }

#line default
#line hidden
#nullable disable
#nullable restore
#line 18 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                 
            }

#line default
#line hidden
#nullable disable
            __builder.CloseElement();
            __builder.AddMarkupContent(11, "\r\n        ");
            __builder.OpenElement(12, "div");
            __builder.AddAttribute(13, "class", "chess-info");
            __builder.AddMarkupContent(14, "<h1>五子棋⚫⚪</h1>\r\n            ");
            __builder.AddMarkupContent(15, "<p><b>⚡是时候表演真正的技术了，快来一场人机大战吧⚡</b></p>\r\n            ");
            __builder.OpenElement(16, "p");
            __builder.OpenElement(17, "label");
            __builder.OpenElement(18, "input");
            __builder.AddAttribute(19, "type", "radio");
            __builder.AddAttribute(20, "name", "chess");
            __builder.AddAttribute(21, "checked", "checked");
            __builder.AddAttribute(22, "onclick", Microsoft.AspNetCore.Components.EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, 
#nullable restore
#line 24 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                                                                     () => first = "ai"

#line default
#line hidden
#nullable disable
            ));
            __builder.CloseElement();
            __builder.AddMarkupContent(23, " 电脑先手");
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.AddMarkupContent(24, "\r\n            ");
            __builder.OpenElement(25, "p");
            __builder.OpenElement(26, "label");
            __builder.OpenElement(27, "input");
            __builder.AddAttribute(28, "type", "radio");
            __builder.AddAttribute(29, "name", "chess");
            __builder.AddAttribute(30, "onclick", Microsoft.AspNetCore.Components.EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, 
#nullable restore
#line 25 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                                                   () => first = "me"

#line default
#line hidden
#nullable disable
            ));
            __builder.CloseElement();
            __builder.AddMarkupContent(31, " 我先手");
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.AddMarkupContent(32, "\r\n            ");
            __builder.OpenElement(33, "p");
            __builder.OpenElement(34, "button");
            __builder.AddAttribute(35, "class", "box-btn");
            __builder.AddAttribute(36, "onclick", Microsoft.AspNetCore.Components.EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, 
#nullable restore
#line 26 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                                 StartGame

#line default
#line hidden
#nullable disable
            ));
            __builder.AddContent(37, 
#nullable restore
#line 26 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                                                              IsInGame ? "结束游戏" : "开始游戏"

#line default
#line hidden
#nullable disable
            );
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.AddMarkupContent(38, "\r\n            ");
            __builder.OpenElement(39, "div");
            __builder.AddAttribute(40, "class", "chess-msg");
            __builder.OpenElement(41, "p");
            __builder.OpenElement(42, "b");
            __builder.AddContent(43, 
#nullable restore
#line 28 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
                       msgs

#line default
#line hidden
#nullable disable
            );
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.AddMarkupContent(44, "\r\n                ");
            __builder.AddMarkupContent(45, "<p>游戏规则：</p>\r\n                ");
            __builder.AddMarkupContent(46, "<span>（1）请选择电脑先手还是你先手，黑棋始终先手。</span>\r\n                ");
            __builder.AddMarkupContent(47, "<span>（2）点击开始游戏按钮开始对局。</span>\r\n                ");
            __builder.AddMarkupContent(48, "<span>（3）点击结束游戏按钮结束对局。</span>\r\n                ");
            __builder.AddMarkupContent(49, "<span>（4）对局双方各执一色棋子。</span>\r\n                ");
            __builder.AddMarkupContent(50, "<span>（5）空棋盘开局。</span>\r\n                ");
            __builder.AddMarkupContent(51, "<span>（6）黑先、白后，交替下子，每次只能下一子。</span>\r\n                ");
            __builder.AddMarkupContent(52, "<span>（7）棋子下在棋盘的空白点上，棋子下定后，不得向其它点移动，不得从棋盘上拿掉或拿起另落别处。</span>\r\n                ");
            __builder.AddMarkupContent(53, "<span>（8）黑方的第一枚棋子可下在棋盘任意交叉点上。</span>\r\n                ");
            __builder.AddMarkupContent(54, "<span>（9）轮流下子是双方的权利，<del>但允许任何一方放弃下子权（即：PASS权）</del>。</span>\r\n                ");
            __builder.AddMarkupContent(55, "<span>（10）<del>五子棋对局，执行黑方指定开局、三手可交换、五手两打的规定。整个对局过程中黑方有禁手，白方无禁手。黑方禁手有三三禁手、四四禁手和长连禁手三种。</del></span>");
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.CloseElement();
            __builder.CloseElement();
        }
        #pragma warning restore 1998
#nullable restore
#line 45 "D:\Github\Blog\src\Meowv.Blog.Web\Components\Gobang.razor"
       
        /// <summary>
        /// 棋盘二维数组 19✖19
        /// </summary>
    private int[,] Chess = new int[19, 19];

    /// <summary>
    /// 先手
    /// </summary>
    private string first = "ai";

    /// <summary>
    /// 是否在游戏中
    /// </summary>
    private bool IsInGame = false;

    /// <summary>
    /// 显示消息
    /// </summary>
    private string msgs;

    /// <summary>
    /// 默认电脑为黑子
    /// </summary>
    private int AIChess = 1;

    /// <summary>
    /// 默认我为白子
    /// </summary>
    private int MineChess = 2;

    /// <summary>
    /// 开始游戏
    /// </summary>
    private void StartGame()
    {
        // 初始化棋盘
        Chess = new int[19, 19];

        // 是否开始游戏，点击按钮重置显示消息
        if (IsInGame)
        {
            msgs = string.Empty;
        }
        else
        {
            // 电脑先手
            if (first == "ai")
            {
                AIChess = 1;
                MineChess = 2;

                // 电脑落子正中心天元位置
                Chess[9, 9] = AIChess;

                msgs = "电脑：执黑子 ⚫ 我：执白子 ⚪";
            }
            else
            {
                // 我先手的话则我执黑子，电脑执白子
                MineChess = 1;
                AIChess = 2;

                msgs = "我：执黑子 ⚫ 电脑：执白子 ⚪";
            }
        }

        // 改变游戏状态，用于显示不同文字的按钮
        IsInGame = !IsInGame;
    }

    /// <summary>
    /// 我方落子
    /// </summary>
    /// <param name="row"></param>
    /// <param name="cell"></param>
    /// <returns></returns>
    private async Task Playing(int row, int cell)
    {
        // 是否开始游戏，当前判断没开始给出提示
        if (!IsInGame)
        {
            await _jsRuntime.InvokeVoidAsync("alert", "\n💪点击开始游戏按钮开启对局，请阅读游戏规则💪");
            return;
        }

        // 已落子直接返回，不做任何操作
        if (Chess[row, cell] != 0)
            return;

        // 根据传进来的坐标进行我方落子
        Chess[row, cell] = MineChess;

        if (IsWin(MineChess, row, cell))
        {
            await _jsRuntime.InvokeVoidAsync("alert", "\n恭喜，你赢了👍");
            IsInGame = !IsInGame;
            return;
        }

        // 我方落子之后电脑落子
        await AIPlaying(AIChess);
    }

    /// <summary>
    /// 电脑落子
    /// </summary>
    /// <param name="chess"></param>
    /// <returns></returns>
    private async Task AIPlaying(int chess)
    {
        // 我方
        var minePoints = new List<ValuedPoint>();
        // 电脑
        var aiPonints = new List<ValuedPoint>();

        for (int i = 0; i < 19; i++)
        {
            for (int j = 0; j < 19; j++)
            {
                // 还未落子的位置列表
                if (Chess[i, j] == 0)
                {
                    minePoints.Add(GetValuedPoint(chess, i, j));

                    aiPonints.Add(GetValuedPoint((chess == 1 ? 2 : 1), i, j));
                }
            }
        }

        // 获取最佳位置
        var minePoint = minePoints.OrderByDescending(x => x.Score).FirstOrDefault();
        var aiPonint = aiPonints.OrderByDescending(x => x.Score).FirstOrDefault();

        if (minePoint != null && aiPonint != null)
        {
            // 如果某个位置对手分数高于我方，则抢占位置
            if (minePoint.Score > aiPonint.Score)
            {
                Chess[minePoint.Point.Row, minePoint.Point.Cell] = chess;

                if (IsWin(AIChess, minePoint.Point.Row, minePoint.Point.Cell))
                {
                    await _jsRuntime.InvokeVoidAsync("alert", "\n电脑赢了，你个渣渣👎");

                    IsInGame = !IsInGame;
                    return;
                }
            }
            else
            {
                Chess[aiPonint.Point.Row, aiPonint.Point.Cell] = chess;

                if (IsWin(AIChess, aiPonint.Point.Row, aiPonint.Point.Cell))
                {
                    await _jsRuntime.InvokeVoidAsync("alert", "\n电脑赢了，你个渣渣👎");
                    IsInGame = !IsInGame;
                    return;
                }
            }
        }
    }

    /// <summary>
    /// 判断是否赢了
    /// </summary>
    /// <param name="chess"></param>
    /// <param name="row"></param>
    /// <param name="cell"></param>
    /// <returns></returns>
    private bool IsWin(int chess, int row, int cell)
    {
        #region 横方向 ➡⬅

        {
            var i = 1;
            var score = 1;
            var rightValid = true;
            var leftValid = true;

            while (i <= 5)
            {
                var right = cell + i;
                if (rightValid && right < 19)
                {
                    if (Chess[row, right] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        rightValid = false;
                }

                var left = cell - i;
                if (leftValid && left >= 0)
                {
                    if (Chess[row, left] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        leftValid = false;
                }

                i++;
            }
        }

        #endregion

        #region 竖方向 ⬇⬆

        {
            var i = 1;
            var score = 1;
            var topValid = true;
            var bottomValid = true;

            while (i < 5)
            {
                var top = row - i;
                if (topValid && top >= 0)
                {
                    if (Chess[top, cell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        topValid = false;
                }

                var bottom = row + i;
                if (bottomValid && bottom < 19)
                {
                    if (Chess[bottom, cell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                    {
                        bottomValid = false;
                    }
                }

                i++;
            }
        }

        #endregion

        #region 撇方向 ↙↗

        {
            var i = 1;
            var score = 1;
            var topValid = true;
            var bottomValid = true;

            while (i < 5)
            {
                var rightTopRow = row - i;
                var rightTopCell = cell + i;
                if (topValid && rightTopRow >= 0 && rightTopCell < 19)
                {
                    if (Chess[rightTopRow, rightTopCell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        topValid = false;
                }

                var leftBottomRow = row + i;
                var leftBottomCell = cell - i;
                if (bottomValid && leftBottomRow < 19 && leftBottomCell >= 0)
                {
                    if (Chess[leftBottomRow, leftBottomCell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        bottomValid = false;
                }

                i++;
            }
        }

        #endregion

        #region 捺方向 ↘↖

        {
            var i = 1;
            var score = 1;
            var topValid = true;
            var bottomValid = true;

            while (i < 5)
            {
                var leftTopRow = row - i;
                var leftTopCell = cell - i;
                if (topValid && leftTopRow >= 0 && leftTopCell >= 0)
                {
                    if (Chess[leftTopRow, leftTopCell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        topValid = false;
                }

                var rightBottomRow = row + i;
                var rightBottomCell = cell + i;
                if (bottomValid && rightBottomRow < 19 && rightBottomCell < 19)
                {
                    if (Chess[rightBottomRow, rightBottomCell] == chess)
                    {
                        score++;
                        if (score >= 5)
                            return true;
                    }
                    else
                        bottomValid = false;
                }

                i++;
            }
        }

        #endregion

        return false;
    }

    /// <summary>
    /// 获取当前位置点的价值分
    /// </summary>
    /// <param name="chess"></param>
    /// <param name="row"></param>
    /// <param name="cell"></param>
    /// <returns></returns>
    private ValuedPoint GetValuedPoint(int chess, int row, int cell)
    {
        var aiChess = chess == 1 ? 2 : 1;

        int HScore = 0, VScore = 0, PScore = 0, LScore = 0;

        #region 横方向 ➡⬅

        {
            var i = 1;
            var score = 1;
            var validPlace = 0;
            var rightValid = true;
            var leftValid = true;
            var rightSpace = 0;
            var leftSpace = 0;
            var isDead = false;

            while (i < 5)
            {
                var right = cell + i;
                if (rightValid && right < 19)
                {
                    if (Chess[row, right] == chess)
                    {
                        if (rightSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[row, right] == 0)
                    {
                        rightSpace++;
                        validPlace++;
                    }
                    else if (Chess[row, right] == aiChess)
                    {
                        rightValid = false;
                        if (rightSpace == 0)
                            isDead = true;
                    }
                }

                var left = cell - i;
                if (leftValid && left >= 0)
                {
                    if (Chess[row, left] == chess)
                    {
                        if (leftSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[row, left] == 0)
                    {
                        leftSpace++;
                        validPlace++;
                    }
                    else if (Chess[row, left] == aiChess)
                    {
                        leftValid = false;
                        if (leftSpace == 0)
                            isDead = true;
                    }
                }

                i++;
            }

            if (score >= 5)
                HScore = 100000;

            if (score == 4)
            {
                if (!isDead)
                    HScore = 80000;
                else
                    HScore = validPlace <= 4 ? 0 : 8000;
            }

            if (score == 3)
            {
                if (!isDead)
                    HScore = validPlace <= 4 ? 0 : 4000;
                else
                    HScore = validPlace <= 4 ? 0 : 2000;
            }

            if (score == 2)
            {
                if (!isDead)
                    HScore = validPlace <= 4 ? 0 : 600;
                else
                    HScore = validPlace <= 4 ? 0 : 300;
            }
        }

        #endregion

        #region 竖方向 ⬇⬆

        {
            var i = 1;
            var score = 1;
            var validPlace = 0;
            var topValid = true;
            var bottomValid = true;
            var topSpace = 0;
            var bottomSpace = 0;
            var isDead = false;

            while (i < 5)
            {
                var top = row - i;
                if (topValid && top >= 0)
                {
                    if (Chess[top, cell] == chess)
                    {
                        if (topSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[top, cell] == 0)
                    {
                        topSpace++;
                        validPlace++;
                    }
                    else if (Chess[top, cell] == aiChess)
                    {
                        topValid = false;
                        if (topSpace == 0)
                            isDead = true;
                    }
                }

                var bottom = row + i;
                if (bottomValid && bottom < 19)
                {
                    if (Chess[bottom, cell] == chess)
                    {
                        if (bottomSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[bottom, cell] == 0)
                    {
                        bottomSpace++;
                        validPlace++;
                    }
                    else if (Chess[bottom, cell] == aiChess)
                    {
                        bottomValid = false;
                        if (bottomSpace == 0)
                            isDead = true;
                    }
                }

                i++;
            }

            if (score >= 5)
                VScore = 100000;

            if (score == 4)
            {
                if (!isDead)
                    VScore = 80000;
                else
                    VScore = validPlace <= 4 ? 0 : 8000;
            }
            if (score == 3)
            {
                if (!isDead)
                    VScore = validPlace <= 4 ? 0 : 4000;
                else
                    VScore = validPlace <= 4 ? 0 : 2000;
            }
            if (score == 2)
            {
                if (!isDead)
                    VScore = validPlace <= 4 ? 0 : 600;
                else
                    VScore = validPlace <= 4 ? 0 : 300;
            }
        }

        #endregion

        #region 撇方向 ↙↗

        {
            var i = 1;
            var score = 1;
            var validPlace = 0;
            var topValid = true;
            var bottomValid = true;
            var topSpace = 0;
            var bottomSpace = 0;
            var isDead = false;

            while (i < 5)
            {
                var rightTopRow = row - i;
                var rightTopCell = cell + i;
                if (topValid && rightTopRow >= 0 && rightTopCell < 19)
                {
                    if (Chess[rightTopRow, rightTopCell] == chess)
                    {
                        if (topSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[rightTopRow, rightTopCell] == 0)
                    {
                        topSpace++;
                        validPlace++;
                    }
                    else if (Chess[rightTopRow, rightTopCell] == aiChess)
                    {
                        topValid = false;
                        if (topSpace == 0)
                            isDead = true;
                    }
                }

                var leftBottomRow = row + i;
                var leftBottomCell = cell - i;
                if (bottomValid && leftBottomRow < 19 && leftBottomCell >= 0)
                {
                    if (Chess[leftBottomRow, leftBottomCell] == chess)
                    {
                        if (bottomSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[leftBottomRow, leftBottomCell] == 0)
                    {
                        bottomSpace++;
                        validPlace++;
                    }
                    else if (Chess[leftBottomRow, leftBottomCell] == aiChess)
                    {
                        bottomValid = false;
                        if (bottomSpace == 0)
                            isDead = true;
                    }
                }

                i++;
            }

            if (score >= 5)
                PScore = 100000;

            if (score == 4)
            {
                if (!isDead)
                    PScore = 80000;
                else
                    PScore = validPlace <= 4 ? 0 : 9000;
            }
            if (score == 3)
            {
                if (!isDead)
                    PScore = validPlace <= 4 ? 0 : 4500;
                else
                    PScore = validPlace <= 4 ? 0 : 3000;
            }
            if (score == 2)
            {
                if (!isDead)
                    PScore = validPlace <= 4 ? 0 : 800;
                else
                    PScore = validPlace <= 4 ? 0 : 500;
            }
        }

        #endregion

        #region 捺方向 ↘↖

        {
            var i = 1;
            var score = 1;
            var validPlace = 0;
            var topSpace = 0;
            var bottomSpace = 0;
            var topValid = true;
            var bottomValid = true;
            var isDead = false;

            while (i < 5)
            {
                var leftTopRow = row - i;
                var leftTopCell = cell - i;
                if (topValid && leftTopRow >= 0 && leftTopCell >= 0)
                {
                    if (Chess[leftTopRow, leftTopCell] == chess)
                    {
                        if (topSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[leftTopRow, leftTopCell] == 0)
                    {
                        topSpace++;
                        validPlace++;
                    }
                    else if (Chess[leftTopRow, leftTopCell] == aiChess)
                    {
                        topValid = false;
                        if (topSpace == 0)
                            isDead = true;
                    }
                }

                var rightBottomRow = row + i;
                var rightBottomCell = cell + i;
                if (bottomValid && rightBottomRow < 19 && rightBottomCell < 19)
                {
                    if (Chess[rightBottomRow, rightBottomCell] == chess)
                    {
                        if (bottomSpace == 0)
                            score++;
                        validPlace++;
                    }
                    else if (Chess[rightBottomRow, rightBottomCell] == 0)
                    {
                        bottomSpace++;
                        validPlace++;
                    }
                    else if (Chess[rightBottomRow, rightBottomCell] == aiChess)
                    {
                        bottomValid = false;
                        if (bottomSpace == 0)
                            isDead = true;
                    }
                }

                i++;
            }

            if (score >= 5)
                LScore = 100000;

            if (score == 4)
            {
                if (!isDead)
                    LScore = 80000;
                else
                    LScore = validPlace <= 4 ? 0 : 9000;
            }

            if (score == 3)
            {
                if (!isDead)
                    LScore = validPlace <= 4 ? 0 : 4500;
                else
                    LScore = validPlace <= 4 ? 0 : 3000;
            }

            if (score == 2)
            {
                if (!isDead)
                    LScore = validPlace <= 4 ? 0 : 800;
                else
                    LScore = validPlace <= 4 ? 0 : 500;
            }
        }

        #endregion

        return new ValuedPoint
        {
            Score = HScore + VScore + PScore + LScore,
            Point = new Point
            {
                Row = row,
                Cell = cell
            }
        };
    }

#line default
#line hidden
#nullable disable
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IJSRuntime _jsRuntime { get; set; }
    }
}
#pragma warning restore 1591
